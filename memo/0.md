# JavaScript 型

```
[object Class.SomeClass]
[object Instance.SomeClass]
[object Error.Class.TypeError]
[object Error.Instance.TypeError]
[object Function.Function]
[object Function.Async]
[object Function.Generator]
[object Function.AsyncGenerator]
[object Object]
[object Class.Array]
[object Instance.Array]
[object Class.Map]
[object Instance.Map]
[object Class.Set]
[object Instance.Set]
[object Class.Float]
[object Instance.Float]
[object Instance.Integer.Positive]
[object Class.Integer.Positive]
[object Instance.Integer.Negattive]
[object Class.Integer.Negative]
[object Instance.Integer.Zero]
[object Class.Integer.Zero]
[object Class.Integer]
[object Instance.Integer]
[object Class.UnsafeInteger]
[object Instance.UnsafeInteger]
[object Class.RangeInteger]
[object Instance.RangeInteger]
[object Class.RangeBigIntInt]
[object Instance.RangeBigIntInt]
[object Class.RangeInteger.Unsigned8]
[object Instance.RangeInteger.Unsigned8]
```
```
[primitive undefined]
[primitive null]
[primitive symbol]
[primitive boolean]
[primitive bigint]
[primitive string]
[primitive number.NaN]
[primitive number.PositiveInfinity]
[primitive number.NegativeInfinity]
[primitive number.SafeInteger]
[primitive number.Integer]
[primitive number.Finite]
```
```
isObjLike();
isPrim();

clsOf(v); // v = SomeClass
insOf(v); // v = SomeClass
prmOf(v); // v = null/undefined/Boolean/BigInt/String/Number(NaN/Infinity/-Infinity/SafeInteger/Integer/Float)
```

## TypeAssertion

```javascript
class TypeAssertion {
    static assert(v, fn) {return fn(new TypeAssertion(v,fn))}
    constructor(v, fn) {this._ = {v:v, fn:fn}}
    get p() {// Primitive
        if (!this.#isPrim) {this.throw(null, null, 'プリミティブ', 'オブジェクト');}
        return PrimitiveAssertion(this._.v, this._.fn);
    }
    get o() {// Object
        if (!this.#isObj) {this.throw(null, null, 'オブジェクト', 'プリミティブ');}
        return ObjectLikeAssertion(this._.v, this._.fn);
    }
    get #isPrim() {return this._.v===Object(this._.v)}
    get #isObj() {return null!==this._.v && 'object'===typeof this._.v}
    throw(t, m, em, am) {
        const T = t ?? TypeError;
        if (!(T instanceof Error)) {throw new TypeError(``)}
        throw new T(`${m ?? '型が期待値と違います。'}\n期待値: ${em}\n実際値: ${am ?? am+' ' : ''}${this._.v}`)
    }
}
```
```javascript
class PrimitiveAssertion extends TypeAssertion {
    constructor(v, fn) {super(v, fn);}
    get isUnd() {return this.#is('undefined')}
    get isNul() {return this.#is('null')}
    get isSym() {return this.#is('symbol')}
    get isBln() {return this.#is('boolean')}
    get isNum() {return this.#is('number')}
    get isInt() {return this.#is('bigint')}
    get isStr() {return this.#is('string')}
    #is(t) {
        if ((t && 'null'!==t) ? (t!==typeof this._.v) : (null!==t)) {this.throw(null, null, t, `${typeof this._.v}`);}
        return true;
    }
}
```
```javascript
class ObjectLikeAssertion extends TypeAssertion {
    constructor(v, fn) {super(v, fn);}
    // Object,Descriptor(DD(value),AD(get/set)),Class,Instance,ErrCls,ErrIns,ArrayLike,Ary,Uint8Array,Map,Set,...,Function,Async,Generator,Arrow,AccessorDescriptor
    get o() {}
    get d() {}
    get c() {}
    get i() {}

    get isC() {}
}
```

## Some

```javascript
class SomeTypedValue {
    static assert(v, a) {
        // a=>v.isP.isNum.isNaN
        // a=>v.isP.isNum.isNaN.value(v=>任意の式。trueを返せば成功)
        // a=>v.isA.length(7).every(v=>'number'===typeof v) // Array
        // a=>v.isM.size(7).has(keys).keys(k=>).value(v=>).entires((k,v)=>) // Map
        // a=>v.isS.size(7).has(keys).keys(k=>).value(v=>).entires((k,v)=>) // Set
        // a=>v.isFn
        // a=>v.isAFn
        // a=>v.isGFn
        // a=>v.isAGFn
        // a=>v.isAFnLike
        // a=>v.isGFnLike
        // a=>v.isFnLike
        // a=>v.isC.hasP('someMethod').hasD('someDescriptor', v=>v.hasGS).hasM('someMethod')
        // a=>v.isI.hasP('someMethod').hasD('someDescriptor', v=>v.hasGS).hasM('someMethod')
        // a=>v.isEC.hasP('someMethod').hasD('someDescriptor', v=>v.hasGS).hasM('someMethod')
        // a=>v.isEI.hasP('someMethod').hasD('someDescriptor', v=>v.hasGS).hasM('someMethod')
        // a=>v.isOL.hasP('someProp') // OL: ObjectLike
        // a=>v.isO.hasP('someProp') // O: Object {}
        // a=>v.isO.hasF('someFunction')
        // a=>v.isO.hasD('someDescriptor')
        // a=>v.isO.hasD('someDescriptor', a=>v.hasGS || v.hasG || v.hasS || v.hasV || v.writable || v.configurable || v.enumerable)
        // a=>v.isO.hasO('someProp')
        // a=>v.isO.hasO('someProp', a=>a.hasP('someProp'))
    }
    static tag(v) {

    }
    static getClass(fn) {
    static getInstance(fn, ...args) {
    static getDefaultValue(fn) {

    }
    constructor(v) {
        this._ = {v:v, t:typeof v};
    }
}
```
```javascript
class SomeTypedValueAssertion {
    constructor(v) {this._ = {v:v}}
    assert(fn) {return fn(this._.v)}
    eq(v) {}
    get isP() {}
    get isA() {}
    get isM() {}
    get isS() {}
    get isC() {}
    get isI() {}
    get isEC() {}
    get isEI() {}
    get isFn() {}
    get isAFn() {}
    get isGFn() {}
    get isAGFn() {}
    get isAFnLike() {}
    get isGFnLike() {}
    get isFnLike() {}
    get isOLike() {}
    get isO() {}
}
class PrimitivedValueAssertion {
    constructor(v) {this._ = {v:v}}
    get isUnd() {}
    get isNul() {}
    get isSym() {}
    get isBln() {}
    get isNum() {}
    get isInt() {}
    get isStr() {}
}
class BooleanedValueAssertion {
    constructor(v) {this._ = {v:v}}
    get isT() {}
    get isF() {}
}
class NumberedValueAssertion {
    constructor(v) {this._ = {v:v}}
    get isNaN() {}
    get isPInf() {}
    get isNInf() {}
    get isFin() {}
    get isP() {}
    get isN() {}
    get isZ() {}
    get isSafeInt() {}
    get isInt() {}
}
class StringedValueAssertion {
    constructor(v) {this._ = {v:v}}
    length(n) {}
}
```

### ObservedValue

```javasctipt
class ObservedValue {
    constructor(v, before, after) {
        this._ = {v:v, before:before, after:after}
        'before after'.split(' ').map(n=>{
            if ([null, undefined].some(v=>v===this._[n])) {this._[n] = (()=>{});}
            if (!isFn(this._[n]) && !isAFn(this._[n])) {throw new TypeError(`${n} はnullかundefinedか非ジェネレータな関数であるべきです。`)}
        });
    }
    get v() {return this._.v}
    set v(v) {
        const o = this._.v;
        const B = this._.before(v, o);
        if (B) { return B }
        this._.v = v;
        const A = this._.after(v, o);
        if (A) { return A }
        return true;
    }
}
```

### TypedValue

```javasctipt
class TypedValue extends ObservedValue {constructor(T, v, before, after) {super(v, ()=>{T.valid(v); return before(v);}, after); this._.T = T; T.valid(v);}}
```

#### TypedValidator

```javasctipt
class TypedValidator {valid(v) {throw Error(`未実装。継承してから実装してください。`)}}
```

#### PrimitivedValidator

```javasctipt
class PrimitiveValidator extends TypedValidator {valid(v){return v!==Object(v)}}
```

#### ObjectLikedValidator

```javasctipt
class ObjectLikedValidator extends TypedValidator {valid(v){return null!==v && 'object'===typeof v}}
```

#### InstancedValidator

```javasctipt
class InstancedValidator extends TypedValidator {
    constructor(C) {
        super();
        if (!C) {C = null}
        if (null!==C || !isCls(C)) {throw new TypeError(`Cはnullかundefinedかクラスであるべきです。`)}
        this._ = {C:C};
    }
    valid(v) {
        if (isPrimitive(v)) return false
        if (isFunction(v)) return false
        if (isCls(v)) return false
        if (isErrCls(v)) return false
        if (isObj(v)) return false
        if (isAry(v)) return false
        return this._.C ? true : v instanceof this._.C;
    }
}
```






## Primitive

```javascript
class PrimitivedValue {
     constructor(v) {
        this._ = {v:v};
        this._.t = typeof v;
        if (!(null===this._.t || 'undefined symbol boolean number bigint string'.split(' ').some(t=>t===this._.t))) {throw new TypeError(`vはプリミティブ値であるべきです。: ${this._.t}, ${v}`)}
    }
    get v() {return this._.v}
    set v(v) {
        const t = typeof v;
        if (this._.t!==t) {throw new TypeError(`代入値はtypeofが ${this._.t} を返す値のみ有効です。: ${t}, ${v}`)}
    }
}
class ValidPrimitivedValue extends PrimitivedValue {
    constructor(v) {
        super(v);
        if (Number.isNaN(v)) {throw new TypeError(`vはNaNを禁じます。`)}
        if (null===v) {throw new TypeError(`vはnullを禁じます。`)}
        if (undefined===v) {throw new TypeError(`vはundefinedを禁じます。`)}
    }
    get v() {return super.v}
    set v(v) {
        if (Number.isNaN(v)) {throw new TypeError(`vはNaNを禁じます。`)}
        super.v = v;
    }
}
```

## Object

```javascript
class ObjectLikedValue {
    constructor(v, nullable=false) {
        this._ = {v:v, t:typeof v, nullable:nullable};
        if ('boolean'!==nullable) {throw new TypeError(`nullableはBoolean値であるべきです。`)}
//        if (!this._.nullable && null===this._.t) {throw new TypeError(`nullableがfalseなのに値がnullです。`)}
//        if ('object'!==this._.t) {throw new TypeError(`vはtypeofで'object'を返す値であるべきです。`)}
        this.v = v;
    }
    get v() {return this._.v}
    set v(v) {
        const t = typeof v;
        if (!this._.nullable && null===v) {throw new TypeError(`nullableがfalseなのに値がnullです。`)}
        if ('object'!==t) {throw new TypeError(`代入値はtypeofが 'object' を返す値のみ有効です。: ${t}, ${v}`)}
        this._.v = v;
    }
}
```
```javascript
class ObjectedValue extends ObjectLikedValue {
    static is(v) {return null!==v && 'object'===typeof v && '[object Object]'===Object.prototype.call.toString(v)}
    constructor(v,nullable=false) {super(v,nullable); this.v = v;}
    get v() {return super.v}
    set v(v) {
        super.v = v;
        if ('[object Object]'!==Object.prototype.call.toString(v)) {throw new TypeError(`代入値はObject.prototype.call.toString(v)が'[object Object]'を返す値のみ有効です。`)}
    }
}
```
```javascript
class ErrorClassedValue extends ObjectLikedValue {
    static is(v) {return Error===v || Error.isPrototypeOf(v)}
    constructor(v,nullable=false) {super(v,nullable); this.v = v;}
    get v() {return super.v}
    set v(v) {
        super.v = v;
        if (!ErrorClassedValue.is(v)) {throw new TypeError(`代入値はError型かそれを継承したクラスオブジェクトであるべきです。`)}
    }
}
class ErrorInstancedValue extends ObjectLikedValue {
    static is(v) {return v instanceof Error}
    constructor(v,nullable=false) {super(v,nullable); this.v = v;}
    get v() {return super.v}
    set v(v) {
        super.v = v;
        if (!ErrorInstancedValue.is(v)) {throw new TypeError(`代入値はError型かそれを継承したクラスのインスタンスオブジェクトであるべきです。`)}
    }
}
class ClassedValue extends ObjectLikedValue {
    static is(v) {return 'function'===typeof v && Boolean(v.toString?.().match(/^class /))}
    constructor(v,nullable=false) {super(v,nullable); this.v = v;}
    get v() {return super.v}
    set v(v) {
        super.v = v;
        if (!('function'===typeof v && Boolean(v.toString?.().match(/^class /))) {throw new TypeError(`代入値はクラスオブジェクトであるべきです。`)}
    }
}
class InstancedValue extends ObjectLikedValue {
    constructor(v, cls=null, nullable=false) {
        super(v,nullable);
        this.v = v;
        this._.cls=cls;
        if (null!==cls && !ErrorClassedValue.is(v)){throw new TypeError(`clsはnullかクラスオブジェクトのみ有効です。`)}
    }
    get v() {return super.v}
    set v(v) {
        super.v = v;
        const t = typeof v;
        if ('function'!==t) {throw new TypeError(`代入値はインスタンスのみ有効なのに関数が渡されました。:${t}, ${v}`)}
        if (!ClassedValue.is(v)) {throw new TypeError(`代入値はインスタンスのみ有効なのにクラスが渡されました。:${t}, ${v}`)}
        if (!ErrorClassedValue.is(v)) {throw new TypeError(`代入値はインスタンスのみ有効なのにエラークラスオブジェクトが渡されました。:${t}, ${v}`)}
        if (!ErrorInstancedValue.is(v)) {throw new TypeError(`代入値はインスタンスのみ有効なのにエラーインスタンスオブジェクトが渡されました。:${t}, ${v}`)}
        if (!ObjectedValue.is(v)) {throw new TypeError(`代入値はインスタンスのみ有効なのにオブジェクトが渡されました。:${t}, ${v}`)}
        if (this._.cls && v !(instanceof this._.cls)) {throw new TypeError(`代入値は${this._.cls.name}クラスのインスタンスのみ有効です。:${t}, ${v}`)}
    }
}
```

### ObservedObject

```javasctipt
class ObservedObject {

}
```

### TypedObject

```javasctipt
class {

}
```

## Function

```javasctipt
class FunctionLikedValue {
    is(v) {return 'function'===typeof v}
    constructor(v, nullable=false) {
        this._ = {v:v, nullable:nullable}
        if ('boolean'!==nullable) {throw new TypeError(`nullableはBoolean値であるべきです。`)}
        this.v = v;
    }
    get v() {return this._.v}
    set v(v) {
        if (!this._.nullable && null===v) {throw new TypeError(`nullableがfalseなのにnullが代入されました。`)}
        if (!FunctionedValue.is(v)) {throw new TypError(`代入値は関数のみ有効です。`)}
        this._.v = v;
    }
}
class FunctionedValue extends FunctionLikedValue {
    static is(v) {return FunctionLikedValue.is(v) && !(AsyncFunctionLikedValue.is(v) || GeneratorFunctionLikedValue(v))}
    constructor(v, nullable=false) {
        super(v, nullable);
        this.v = v;
    }
    get v() {return super.v}
    set v(v) {
        super.v = v;
        if (!FunctionedValue.is(v)) {throw new TypeError(`非同期でもジェネレータでもない関数のみ有効です。:${v}`)}
    }
}
class AsyncFunctionedValue extends FunctionLikedValue {
    static #T = (async()=>{}).constructor;
    static is(v) {return v instanceof this.#T}
    constructor(v, nullable=false) {
        super(v, nullable);
        this.v = v;
    }
    get v() {return super.v}
    set v(v) {
        super.v = v;
        if (!AsyncFunctionedValue.is(v)) {throw new TypeError(`非同期関数のみ有効です。:${v}`)}
    }
}
class GeneratorFunctionedValue extends FunctionLikedValue {
    static #T = (function*(){yield undefined;}).constructor;
    static is(v) {return v instanceof this.#T}
    constructor(v, nullable=false) {
        super(v, nullable);
        this.v = v;
    }
    get v() {return super.v}
    set v(v) {
        super.v = v;
        if (!GeneratorFunctionedValue .is(v)) {throw new TypeError(`ジェネレータ関数のみ有効です。:${v}`)}
    }
}
class AsyncGeneratorFunctionedValue extends FunctionLikedValue {
    static #T = (async function*(){yield undefined;}).constructor;
    static is(v) {return v instanceof this.#T}
    constructor(v, nullable=false) {
        super(v, nullable);
        this.v = v;
    }
    get v() {return super.v}
    set v(v) {
        super.v = v;
        if (!AsyncGeneratorFunctionedValue.is(v)) {throw new TypeError(`非同期ジェネレータ関数のみ有効です。:${v}`)}
    }
}

class AsyncFunctionLikedValue extends FunctionLikedValue {
    static is(v) {return AsyncFunctionedValue.is(v) || AsyncGeneratorFunctionedValue.is(v)}
    constructor(v, nullable=false) {
        super(v, nullable);
        this.v = v;
    }
    get v() {return super._.v}
    set v(v) {
        super.v = v;
        if (!AsyncGeneratorFunctionedValue.is(v)) {throw new TypeError(`非同期系関数のみ有効です。:${v}`)}
    }
}
class GeneratorFunctionLikedValue extends FunctionLikedValue {
    static is(v) {return GeneratorFunctionedValue.is(v) || AsyncGeneratorFunctionedValue.is(v)}
    constructor(v, nullable=false) {
        super(v, nullable);
        this.v = v;
    }
    get v() {return super._.v}
    set v(v) {
        super.v = v;
        if (!GeneratorFunctionLikedValue.is(v)) {throw new TypeError(`ジェネレータ系関数のみ有効です。:${v}`)}
    }
}
```

### Function(Optional/Overload)

```javascript
class OptionalFunction {

}
```

```javascript
class OverloadFunction {

}
```


## Number型

* NaN,Infinity,-Infinityを除外する
* IEEE754倍精度浮動小数点のうち
    * 誤差が生じないSafeInteger
    * 誤差が生じるInteger
    * 誤差が生じるFinite(Float)

```javascript
class Finite extends Number {
    constructor(v) {this._={v:0}; this.v=v;}
    get v() {return this._.v}
    set v(v) {
        if (Number.isFinite(v)) {throw new TypeError(`代入値が不正です。Number.isFinite()がtrueを返す値のみ有効です。`)}
        this._.v = v;
    }
}
class Integer extends Finite {
    constructor(v) {super(v); this.v=v;}
    get v() {return this._.v}
    set v(v) {
        if (Number.isInteger(v)) {throw new TypeError(`代入値が不正です。Number.isInteger()がtrueを返す値のみ有効です。`)}
        this._.v = v;
    }
}
class SafeInteger extends Integer {
    constructor(v) {super(v); this.v=v;}
    get v() {return this._.v}
    set v(v) {
        if (Number.isSafeInteger(v)) {throw new TypeError(`代入値が不正です。Number.isInteger()がtrueを返す値のみ有効です。`)}
        this._.v = v;
    }
}
```

### RangedNumber型

　Finite,Integer,SafeIntegerの中でも更に範囲を限定する。

```javascript
class Range {static valid(min,max) {if (max <= min) {throw new RangeError(`min < maxであるべきです。`)}}}
class NumberTypedRange {
    static get validTypes() {return [Finite,Integer,SafeInteger]}
    constructor(T, min, max, v) {
        this._ = {T:T};
        if (!TypedRange.validTypes.some(t=>t===T)) {throw new TypeError(`Tは${TypedRange.validTypes}のいずれかであるべきです。`)}
        this._.min = new T(min);
        this._.max = new T(max);
        if (max <= min) {throw new RangeError(`min < maxであるべきです。`)}
        this._.v = new T(v ?? 0);
    }
    get min() {return this._.min.v}
//    set min(v) {this._.min.v=v}
    get max() {return this._.max.v}
//    set max(v) {this._.max.v=v}    
    get v() {return this._.v.v}
    set v(v) {this._.v.v=v}    
}
class RangedFinite extends NumberTypedRange {constructor(min,max,v) {super(Finite,min,max,v)}}
class RangedInteger extends NumberTypedRange {constructor(min,max,v) {super(Integer,min,max,v)}}
class RangedSafeInteger extends NumberTypedRange {constructor(min,max,v) {super(SafeInteger,min,max,v)}}
class RangedBigInt {
    static get validTypes() {return [Finite,Integer,SafeInteger,BigInt]}
    constructor(min, max, v) {
        this._ = {};
        if ([min,max].every('bigint'!==v)) {throw new TypeError(`min,maxは共にtypeofが'bigint'を返す値であるべきです。`)}
        this._.min = BigInt(min);
        this._.max = BigInt(max);
        if (max <= min) {throw new RangeError(`min < maxであるべきです。`)}
        this._.v = BigInt(v ?? 0n);
        this.#valid(v);
    }
    get min() {return this._.min}
//    set min(v) {this.#valid(v); this._.min=v}
    get max() {return this._.max}
//    set max(v) {this.#valid(v); this._.max=v}    
    get v() {return this._.v}
    set v(v) {this.#valid(v); this._.v=v}    
    #valid(v) {if ('bigint'!==v) {throw new TypeError(`vはtypeofが'bigint'を返す値であるべきです。`)}}
}

### TwoPowRangedNumber型

　範囲制限の中でも2の冪乗である数。

```javascript
class SignedInteger8   extends RangedSafeInteger {constructor(v) {super(-128, 127, v);}}
class SignedInteger16  extends RangedSafeInteger {constructor(v) {super(-32768, 32767, v);}}
class SignedInteger32  extends RangedSafeInteger {constructor(v) {super(-2147483648, 2147483647, v);}}
class SignedInteger64  extends RangedBigInt {constructor(v) {super(-9223372036854775808n, 9223372036854775807n, v);}}
class SignedInteger128 extends RangedBigInt {constructor(v) {super(-170141183460469231731687303715884105728n, 170141183460469231731687303715884105727n, v);}}
class SignedInteger256 extends RangedBigInt {constructor(v) {super(-57896044618658097711785492504343953926634992332820282019728792003956564819968n, 57896044618658097711785492504343953926634992332820282019728792003956564819967n, v);}}
class UnsignedInteger8   extends RangedSafeInteger {constructor(v) {super(0, 256, v);}}
class UnsignedInteger16  extends RangedSafeInteger {constructor(v) {super(0, 65536, v);}}
class UnsignedInteger32  extends RangedSafeInteger {constructor(v) {super(0, 4294967295, v);}}
class UnsignedInteger64  extends RangedBigInt {constructor(v) {super(0n, 18446744073709551615n, v);}}
class UnsignedInteger128 extends RangedBigInt {constructor(v) {super(0n, 340282366920938463463374607431768211455n, v);}}
class UnsignedInteger256 extends RangedBigInt {constructor(v) {super(0n, 115792089237316195423570985008687907853269984665640564039457584007913129639935n, v);}}
newTwoPowInteger(pow, signed, value) {
    if (Number.isSafeInteger(pow) && 0 < pow) {throw new TypeError(`powはNumber.isSafeInteger()がtrueを返す値で0より大きい数であるべきです。`)}
    if ('boolean'!==typeof signed) {throw new TypeError(`signedは真偽値であるべきです。`)}
    const [min,max] = pow < 53
        ? [(signed ? ((2**pow) / 2) * -1) : 0), (((2**pow) / (signed ? 2 : 1)) - 1)]
        : [(signed ? ((2n**pow) / 2n) * -1n) : 0n), (((2n**pow) / (signed ? 2n : 1n)) - 1n)]
    const T = pow < 53 ? RangedBigInt : RangedSafeInteger;
    return new T(min,max,value);
}
window.Typed = new Proxy({},{
    get(target, prop, receiver) {
        const R = /^(?<signed>(i|u))(?<bits>\d+)$/;
        const m = prop.match(R);
        if (!m) {throw new TypeError(`プロパティ名が不正です。次の正規表現に従った名前にしてください。${R}`)}
        const signed = 'i'===m.groups.signed ? true : false;
        const bits = parseInt(m.groups.bits);
        if (!(0 < bits && (0===(bits & (bits - 1)))) {throw new RangeError(`bitsは8以上かつ2の冪乗であるべきです。例:8,16,32,64,128,256`)}
        return newTwoPowInteger(pow, signed, value);
    }
});
window.Typed.i(); // Number.isSafeInteger()全部
window.Typed.u(); // 0以上のNumber.isSafeInteger()全部
window.Typed.f(); // Finite（UnsafeなIntegerを含む。浮動小数点数を含む）
window.Typed.u8();
window.Typed.u8(0);
window.Typed.i8(0);
window.Typed.u16(0);
window.Typed.u32(0);
window.Typed.u64(0);
window.Typed.u128(0);
window.Typed.u256(0);
window.Typed.ir(min,max,v); // 整数範囲
window.Typed.ur(max,v);     // 整数範囲
window.Typed.fr(min,max,v); // 実数範囲
```

## 乱数

```javascript
window.Random.f(min, max); // min,maxの範囲内を均等分布で出力する
window.Random.i(min, max); // min,maxの範囲内を均等分布で出力する
window.Random.u(max); // min,maxの範囲内を均等分布で出力する
window.Random.u8; // min,maxの範囲内を均等分布で出力する
window.Random.i8; // min,maxの範囲内を均等分布で出力する
```
```javascript
window.Random.id;    // UnsignedInteger,128bitsの乱数。内部ではUint8ArrayやBase64化した文字列を持
window.Random.id256; // UnsignedInteger,256bitsの乱数。内部ではUint8ArrayやBase64化した文字列を持
```

# 全部

```javascript
window.Typed = {
    some: (v)=>,
    Primitive: (v)=>new PrimitivedValue(v),
    ObjectLike: (v)=>new ObjectLikedValue(v),
    Object: (v)=>new ObjectedValue(v),
    Class: (v)=>new ClassedValue(v),
    Instance: (v)=>new InstanceedValue(v),
    ErrorClass: (v)=>new ErrorClassedValue(v),
    ErrorInstance: (v)=>new ErrorInstanceedValue(v),
    Number: new Proxy({
            f: (v)=>new Finite(v),
            i: (v)=>new SafeInteger(v),
            u: (v)=>new RangedSafeInteger(Number.SAFE_MAX_INTEGER, v),
            fr: (min,max,v)=>new RangedFinite(min,max,v),
            ir: (min,max,v)=>new RangedSafeInteger(min,max,v),
            ur: (max,v)=>new RangedSafeInteger(0,max,v),
        },{
        get(target, prop, receiver) {
            if (prop in target) {return Reflect.get(target, prop)}
            const R = /^(?<signed>(i|u))(?<bits>\d+)$/;
            const m = prop.match(R);
            if (!m) {throw new TypeError(`プロパティ名が不正です。次の正規表現に従った名前にしてください。${R}`)}
            const signed = 'i'===m.groups.signed ? true : false;
            const bits = parseInt(m.groups.bits);
            if (!(0 < bits && (0===(bits & (bits - 1))))) {throw new RangeError(`bitsは8以上かつ2の冪乗であるべきです。例:8,16,32,64,128,256`)}
            return newTwoPowInteger(pow, signed, value);
        }
    }),
    Random: {
        id: ()=>new RID(),
    },
    BiasRandom: {
        
    },
};
```


































Arrayはコンストラクタ関数でありES6で導入された「class {}」で実装されていないからES6クラスではない。だがES6「class extends Array {}」で継承することはできる。だからArrayもクラスである。ということですか？




コンストラクタ、クラス、アロー関数式、一般的な関数はすべて関数オブジェクトだが、これらを区別したい。このとき、次のような式で合っているか。

```javascript
// ES6以前に生成されりネイティブ実装されたクラス（Array, Uint8Array等）か
const isConstructor = (v) =>'function'===typeof v && !!v.prototype && v.prototype.constructor === v;
// ES6以降のclass{}構文で実装した自前クラス＝コンストラクタ＝特殊な関数オブジェクト（class C {}等）か
const isCls = (v)=>(('function'===typeof v) && (!!v.toString().match(/^class /)));
// 関数か（コンストラクタでなくクラスでなく）
const isFunction = (v) =>'function'===typeof v && !isConstructor(v) && !isCls(v);
// Arrow関数式（prototypeを持たない関数オブジェクト()=>{}等）か
const isArrowFunction = (v) =>'function'===typeof v && !v.prototype;
// 一般的な関数か（function fn(){}、new Function()、{fn(){}}等で定義されたコンストラクタでもクラスでもない関数オブジェクトか）
const isDefinedFunction = (v) =>'function'===typeof v && !!v.prototype && v.prototype.constructor !== v;
```
```javascript
isConstructor(Array); // true
isCls(Array); // false
isFunction(Array); // false
isArrowFunction(Array); // false
isDefinedFunction(Array); // false
```
```javascript
const C = class C {};
isConstructor(C); // false
isCls(C); // true
isFunction(C); // false
isArrowFunction(C); // false
isDefinedFunction(C); // false
```

関数系オブジェクトの区別をする関数を作りたいです。コンストラクタ、クラス、アロー関数式、一般的な関数を区別したいです。次の式で合っているか確認してください。

```javascript
// 関数系全般の区別をする（コンストラクタ、クラス、アロー関数式、一般的な関数）
// コンストラクタ関数かクラスか関数なら真を返す
const isConClsFn = (v) =>'function'===typeof v;
// コンストラクタ関数かクラスなら真を返す
const isConCls = (v) =>'function'===typeof v && !!v.prototype && v.prototype.constructor === v;
// ES6以前に生成されりネイティブ実装されたクラス（Array, Uint8Array等）なら真を返す
const isConstructor = (v) =>'function'===typeof v && !!v.prototype && v.prototype.constructor === v && (!v.toString().match(/^class /));
// ES6以降のclass{}構文で実装した自前クラス＝コンストラクタ＝特殊な関数オブジェクト（class C {}等）なら真を返す
const isCls = (v)=>(('function'===typeof v) && (!!v.toString().match(/^class /)));
// 関数（コンストラクタでなくクラスでなく）なら真を返す
const isFunction = (v) =>'function'===typeof v && !isConstructor(v) && !isCls(v);
// Arrow関数式（prototypeを持たない関数オブジェクト()=>{}等）なら真を返す
const isArrowFunction = (v) =>'function'===typeof v && !v.prototype;
// 一般的な関数なら真を返す（function fn(){}、new Function()、{fn(){}}.fn、Object.defineProperty({},'n',{get(){return 1}}).n等で定義されたコンストラクタでもクラスでもない関数オブジェクトなら真を返す）
const isDefinedFunction = (v) =>'function'===typeof v && !!v.prototype && v.prototype.constructor !== v;
```

```javascript
// 1. 全ての関数系 (Class, Function, Arrow, Async, etc...)
const isCallable = (v) => typeof v === 'function';

// 2. ES6 class構文で定義されたもの (class C {})
const isEs6Class = (v) => isCallable(v) && v.toString().startsWith('class ');

// 3. new 演算子で呼び出し可能なもの (ES5以前の関数、Arrayなどの組み込み、ES6クラス)
// ※メソッド定義やアロー関数は prototype を持たないのでここで弾ける
const isConstructor = (v) => isCallable(v) && !!v.prototype;

// 4. ネイティブ実装やES5形式のクラス（Array, Uint8Array, function OldClass(){}）
const isNativeOrEs5Class = (v) => isConstructor(v) && !v.toString().startsWith('class ');

// 5. new できない「純粋な関数」 (アロー関数、オブジェクトのメソッド定義 { m(){} })
const isNonConstructorFunction = (v) => isCallable(v) && !v.prototype;

// 6. アロー関数 (() => {}) の判定
// ※メソッド定義と区別するには toString() のチェックが必要な場合があるが、実用上は 5 と同等
const isArrowFunction = (v) => isNonConstructorFunction(v) && !v.toString().match(/^\w+\s*\(/);
```

* isCallable
    * isConstructor
        * isEs6Class
        * isNativeOrEs5Class
    * isNonConstructorFunction アロー関数やメソッド
        * isArrowFunction

isCallable(function(){}) // true
isConstructor(function(){}) // true ! falseになって欲しい。メソッドやアロー関数しか弾けない！
isEs6Class(function(){})// false
isNativeOrEs5Class(function(){}) // true
isNonConstructorFunction(function(){}) // false ! trueになって欲しい。メソッドやアロー関数しか通さない！
isArrowFunction(function(){}) // false


1. 各式の検証結果

関数名	判定対象	評価と注意点
isConClsFn	全般	[OK] すべての関数オブジェクトを捕捉できます。
isConCls	コンストラクタ/クラス	[要注意] function fn(){} で定義した普通の関数もtrueになります。 JSではアロー関数等を除き、普通の関数はすべてコンストラクタとして振る舞えるためです。
isConstructor	ネイティブ/ES5クラス	[概ねOK] ただし後述の「メソッド定義」との区別が必要です。
isCls	ES6クラス	[OK] toString() を使うこの方法は、現在もES6クラスを判別する事実上の標準的な手法です。
isFunction	純粋な関数	[要修正] isConstructorが「普通の関数」を真と判定してしまうため、このままだと常に偽になる可能性があります。
isArrowFunction	アロー関数	[OK] アロー関数と、オブジェクト内のメソッド定義（{ fn(){} }）を捕捉できます。
isDefinedFunction	一般的な関数	[要修正] v.prototype.constructor !== v は通常成立しません（基本は循環参照で一致します）。

2. 修正が必要なポイント：JSの「関数」の二面性

　JavaScriptにおいて、function fn(){} で作った関数は、「関数」であると同時に「コンストラクタ（newできる）」でもあります。 これを「ただの関数（non-constructor）」として定義時に区別するプロパティは存在しません。

　唯一の例外は、「メソッド定義（Method definitions）」と「アロー関数」です。これらは prototype を持たず、new できません。

修正のアドバイス

    v.prototype.constructor !== v について:
    通常の function f(){} では f.prototype.constructor === f は常に true です。そのため、この条件で「一般的な関数」を抽出することはできません。
    「一般的な関数」の定義:
    もし「function fn(){} の形式で書かれたもの」を指すのであれば、それは JavaScript の仕様上、Array 等と区別がつかない（どちらも new 可能な関数オブジェクトである）という点に注意してください。

もし「new されたくない関数」を厳密に作りたい場合は、ES6 以降では const fn = () => {}（アロー関数）や { method() {} }（メソッド定義）を使うのが現在の標準的な設計方針となっています。



　JavaScriptではコンストラクタ関数と非コンストラクタ関数を区別することができないという認識で合っていますか？


```javascript
isConClsFn(Array); // true
isConClsFn(Array); // true
isConCls(Array); // true
isConCls(C); // true
```
```javascript
const ArrFn = (()=>{});
isConClsFn(ArrFn); // true
isConCls(ArrFn); // false
isConstructor(ArrFn); // false
isCls(ArrFn); // false
isFunction(ArrFn); // true
isArrowFunction(ArrFn); // true
isDefinedFunction(ArrFn); // false
```
```javascript
class Callal extends TypedAssertion {// 呼出可能なもの（コンストラクタ、クラス、関数、アロー関数）
    static is(v, fn) {
        if ('function'!==typeof v) {this._throw(null, null, `関数 'function'===typeof v`, `${typeof v}`)}
        return new Functional(v, fn);
    }
    constructor(v, fn) {super(v, fn)}
    assert(v) {
        
    }
    get isFn() {}
    get isArrFn() {}
    get isDefFn() {}
}
```
```javascript
class Classal {// コンストラクタかクラスな関数
    static is(v) {return 'function'===typeof v && !!v.prototype && v.prototype.constructor === v}
    constructor(v, fn) {super(v, fn)}
    get isConClsFn() {}
    get isConCls() {}
    get isCon() {}
    get isCls() {}
}
```
```javascript
class Functional {// コンストラクタでもクラスでもない関数（またはアロー関数）
    static is(v) {return 'function'===typeof v && !Classal.is(v)}
    constructor(v, fn) {super(v, fn)}
    get isArrFn() {}
    get isDefFn() {}
}
```
```javascript
class ArrowFunction {// アロー関数
    static is(v) {return 'function'===typeof v && !v.prototype}
    constructor(v, fn) {super(v, fn)}
    get isAsync() {}
    get isGenerator() {}
    get isAsyncGenerator() {}
    get hasAsync() {}
    get hasGenerator() {}
    get notAsync() {}
    get notGenerator() {}
    get notAsyncGenerator() {}
}
```
```javascript
class DefineFunction {// 一般的な関数（アロー関数、コンストラクタ、クラスでもない）
    static is(v) {return 'function'===typeof v && !!v.prototype && v.prototype.constructor !== v}
    constructor(v, fn) {super(v, fn)}
    get isAsync() {}
    get isGenerator() {}
    get isAsyncGenerator() {}
    get hasAsync() {}
    get hasGenerator() {}
    get notAsync() {}
    get notGenerator() {}
    get notAsyncGenerator() {}
}
```
```javascript
function fn() {return 1}
```
```javascript
const o = ({fn(){return 1}});
const odfn = o.fn.bind(o);
isConClsFn(ArrFn); // true
isConCls(ArrFn); // false
isConstructor(ArrFn); // false
isCls(ArrFn); // false
isFunction(ArrFn); // true
isArrowFunction(ArrFn); // true
isDefinedFunction(ArrFn); // false
```

```javascript
const o0 = ({fn:function(){return 0}});
const o1 = ({fn(){return 1}});
const o2 = ({fn:()=>1});
const o3 = ({get:function(){return 1}});
const o4 = ({get(){return 1}});
const o5 = ({get:()=>1});
const d0  = Object.defineProperty({}, 'n', {value:0});
const d1  = Object.defineProperty({}, 'n', {value:function(){return 1}});
const d2  = Object.defineProperty({}, 'n', {value(){return 2}});
const d3  = Object.defineProperty({}, 'n', {value:()=>3});
const d4  = Object.defineProperty({}, 'n', {get:4}); // TypeError: property descriptor's get field is neither undefined nor a function
const d5  = Object.defineProperty({}, 'n', {get:function(){return 5}});
const d6  = Object.defineProperty({}, 'n', {get(){return 6}});
const d7  = Object.defineProperty({}, 'n', {get:()=>7});
const d8  = Object.defineProperty({}, 'n', {set:8});
const d9  = Object.defineProperty({}, 'n', {set:function(v){return 9}});
const d10 = Object.defineProperty({}, 'n', {set(v){return 10}});
const d11 = Object.defineProperty({}, 'n', {set:(v)=>11});
const d12 = Object.defineProperty({}, 'n', {get:12});
const d13 = Object.defineProperty({}, 'n', {get:function(){return 12}, set:function(){return 120}});
const d14 = Object.defineProperty({}, 'n', {get(){return 13}, set(){return 130}});
const d15 = Object.defineProperty({}, 'n', {get:()=>14, set:()=>140});


const d2 = Object.defineProperty({get:()=>1});
const odFn = o.fn.bind(o0);
const values = [
    Array,
    class C {},
    function(){},

];
```




// Object.defineProperty()で実装したディスクリプタか
const isDescriptor = (v)=>Object.hasOwnProperty('value') || 'get set'.sprit(' ').some(n=>Object.hasOwnProperty(n) && 'function'===typeof n);

console.log(isConstructor(Array));      // true
console.log(isConstructor(Uint8Array)); // true
console.log(isConstructor(class {}));   // true
console.log(isConstructor(() => {}));   // false（アロー関数はクラスではない）

Array判定: Array.isArray(obj)
Uint8Array判定: obj instanceof Uint8Array

ES6以前の自称クラスはその実態が関数オブジェクトということですか？　それともES6クラスもまた関数オブジェクトであり「class {}」という構文はあくまで関数オブジェクトを生成する糖衣構文に過ぎないということですか？

isConstructor() {}
isClass




































js ArrayやUint8Arrayはクラスではないのか

JavaScriptにおいて、
ArrayやUint8Arrayは技術的には「クラス（コンストラクタ関数）」です。
厳密には以下の性質を持っています。
1. class 構文の導入以前からの「クラス」
JavaScriptにおける「クラス」は、内部的にはプロトタイプベースのオブジェクトです。ES6（2015年）でclass構文が導入されましたが、それ以前からあるArrayなどは、動作上、現在のclassと同じ役割を果たしています。 

    インスタンス化: new Array() や new Uint8Array() のように new 演算子でインスタンスを生成できます。
    継承: Array を継承して独自のクラスを作ることも可能です（例: class MyArray extends Array {}）。

2. 型の確認
typeof と instanceof を使うと、これらが関数（コンストラクタ）であり、生成されたものがそのインスタンスであることが確認できます。 
javascript

console.log(typeof Array);        // "function" (クラスの正体は関数)
console.log(typeof Uint8Array);   // "function"

const arr = new Array();
console.log(arr instanceof Array); // true

コードは注意してご使用ください。
3. Uint8Array の特殊性
Uint8Array は、TypedArray（型付き配列）と呼ばれるグループの一種です。
これらは共通の内部クラス（%TypedArray%）を継承しており、メモリ効率やバイナリデータ操作に特化した設計になっています。 
まとめ

    Array: 標準的な動的配列クラス。
    Uint8Array: 8ビット符号なし整数の固定長配列クラス。

どちらもオブジェクト指向の文脈では「クラス」として扱われますが、JavaScriptの仕様（ECMAScript）上では「組み込みオブジェクト（Built-in objects）」の「コンストラクタ」と定義されています。

    なぜJavaScriptにおいて『オブジェクト』という言葉は二重に使われているのか - OPTiM TECH BLOG
    2021/08/15 — JavaもC++もRubyもPythonもクラスベースのオブジェクト指向です。 一方、JavaScr...
    OPTiM TECH BLOG

【徹底解説】JavaScriptのclassを理解する
2023/06/13 — classの登場 class は、ECMAScript 2015（またはES6）で導入されました。 ...
Qiita
JavaScript における型判定手法について
2024/08/26 — 手法のまとめ ここまで4つの手法を見てきた。 先ほども言ったが、プリミティブ型に限定すれば type...
Qiita

すべて表示
クラスであるか否かは次の式で確認できる。「isCls = (v)=>(('function'===typeof v) && (!!v.toString().match(/^class /)));
」。「class C {}」を作り「isCls(C)」で真を返す。だが「isCls(Array)」は偽を返す。よってクラスではないと判断したのだが、それは間違いか？　間違いならどうやってクラスか否かを判断すればいいか？
結論から申し上げますと、
「ArrayやUint8Arrayはクラスである」というのは間違いではありません。
質問者様が作成された isCls 関数は、「ES6の class 構文で定義されたかどうか」を判定していますが、JavaScriptにおける「クラス」という概念はそれよりも広義であるため、判定結果に齟齬が生じています。
1. なぜ isCls(Array) が偽になるのか
Array や Uint8Array は、ES6（2015年）で class 構文が登場するずっと前から存在する組み込みのコンストラクタ関数です。

    class 構文で書かれたクラス: toString() を実行すると "class ..." で始まる文字列を返します。
    組み込みクラス（Array等）: 内部的にネイティブコードで実装されているため、toString() は function Array() { [native code] } のような形式を返し、class というキーワードを含みません。 

しかし、どちらも「new でインスタンス化できる」「プロトタイプを持つ」「継承できる」というクラスとしての性質を備えています。
2. 「クラスか否か」をどう判断すべきか
現代のJavaScriptにおいて、あるオブジェクトがクラス（コンストラクタ）であるかを厳密に判定するには、単なる文字列マッチングではなく、「new 演算子で呼び出し可能か」を確認するのが最も正確です。
ただし、JavaScriptには「安全に new できるか事前に調べる」標準的な関数がないため、以下の方法が一般的です。
A. プロトタイププロパティの有無で判定（簡易版）
通常の関数やクラスは prototype を持っていますが、アロー関数などは持っていません。
javascript

const isConstructor = (v) => {
  return typeof v === 'function' && !!v.prototype && v.prototype.constructor === v;
};

console.log(isConstructor(Array));      // true
console.log(isConstructor(Uint8Array)); // true
console.log(isConstructor(class {}));   // true
console.log(isConstructor(() => {}));   // false（アロー関数はクラスではない）

コードは注意してご使用ください。
B. 組み込みの「型」として判定する
特定の組み込みクラスかどうかを知りたい場合は、Array.isArray() や instanceof を使用するのが正攻法です。

    Array判定: Array.isArray(obj)
    Uint8Array判定: obj instanceof Uint8Array

まとめ

    質問者様の式は「ES6の新しい書き方で作られたクラスか」を判定する式としては正しいです。
    しかし、JavaScriptの仕様上、Array や Uint8Array は「組み込みクラス」であり、コンストラクタ関数として定義されているため、広義のクラスに含まれます。

    In javascript, what are the differences between a class and ...
    2017/10/17 — A class is a constructor technically. Any object w...
    Stack Overflow

ES6以前の自称クラスはその実態が関数オブジェクトということですか？　それともES6クラスもまた関数オブジェクトであり「class {}」という構文はあくまで関数オブジェクトを生成する糖衣構文に過ぎないということですか？
ご認識の通り、
ES6の「class」もまた、実態は関数オブジェクトであり、糖衣構文（シンタックスシュガー）に過ぎません。 
JavaScriptの内部構造においては、ES6以前のコンストラクタ関数もES6の class 構文も、最終的には同じ「プロトタイプベースの継承」という仕組みの上で動いています。 
1. ES6クラスの実態は「特殊な関数」
ES6の class 構文を使ってクラスを定義しても、その型を確認すると function となります。 
javascript

class MyClass {}
console.log(typeof MyClass); // "function"

コードは注意してご使用ください。
MDNのドキュメントでも「クラスは実際には『特別な関数』です」と明記されています。 
2. 「糖衣構文」としての役割
class 構文が導入された理由は、新しい仕組みを作るためではなく、従来の複雑なプロトタイプ操作をより簡潔かつ安全に書けるようにするためです。 
機能 
	従来の書き方（ES5以前）	ES6の class 構文
実態	コンストラクタ関数	関数オブジェクト（糖衣構文）
継承	Parent.call(this) や Object.create など複数の手順が必要	extends キーワードで完結
安全性	new なしで実行できてしまう（バグの原因）	new なしで呼ぶとエラーを投げる
3. ArrayやUint8Arrayが class 構文の判定に引っかからない理由
Array や Uint8Array が v.toString().match(/^class /) で偽になるのは、これらが 「ネイティブ（実行エンジン内部）で実装された関数」 だからです。 

    ES6クラス: 文字列化すると "class ..." で始まる。
    組み込みクラス（Arrayなど）: 文字列化すると "function Array() { [native code] }" となり、class キーワードを含まない。 

結論
質問者様が仰る通り、「class {}」は関数オブジェクトを生成するための糖衣構文です。 
そのため、JavaScriptにおいて「クラスか否か」を判断する最も広い定義は、class というキーワードの有無ではなく、「new 演算子でインスタンスを生成できる関数オブジェクト（コンストラクタ）かどうか」となります。 

    Classes - JavaScript - MDN Web Docs
    2025/07/07 — Defining classes. Classes are in fact "special fun...
    MDN Web Docs

ES6 Classes vs Constructor Functions: Which to Use in 2025?
2025/09/01 — Segev Minyan. Software Engineer. 3mo. Constructor ...
LinkedIn
ES6 Classes: OOP in Javascript - Medium
2023/11/09 — ECMAScript 2015, also known as ES6 and ES2015, int...
Medium

すべて表示
関数系オブジェクトの区別をする関数を作りたいです。コンストラクタ、クラス、アロー関数式、一般的な関数を区別したいです。次の式で合っているか確認してください。

```javascript
// 関数系全般の区別をする（コンストラクタ、クラス、アロー関数式、一般的な関数）
// コンストラクタ関数かクラスか関数なら真を返す
const isConClsFn = (v) =>'function'===typeof v;
// コンストラクタ関数かクラスなら真を返す
const isConCls = (v) =>'function'===typeof v && !!v.prototype && v.prototype.constructor === v;
// ES6以前に生成されりネイティブ実装されたクラス（Array, Uint8Array等）なら真を返す
const isConstructor = (v) =>'function'===typeof v && !!v.prototype && v.prototype.constructor === v && (!v.toString().match(/^class /));
// ES6以降のclass{}構文で実装した自前クラス＝コンストラクタ＝特殊な関数オブジェクト（class C {}等）なら真を返す
const isCls = (v)=>(('function'===typeof v) && (!!v.toString().match(/^class /)));
// 関数（コンストラクタでなくクラスでなく）なら真を返す
const isFunction = (v) =>'function'===typeof v && !isConstructor(v) && !isCls(v);
// Arrow関数式（prototypeを持たない関数オブジェクト()=>{}等）なら真を返す
const isArrowFunction = (v) =>'function'===typeof v && !v.prototype;
// 一般的な関数なら真を返す（function fn(){}、new Function()、{fn(){}}.fn、Object.defineProperty({},'n',{get(){return 1}}).n等で定義されたコンストラクタでもクラスでもない関数オブジェクトなら真を返す）
const isDefinedFunction = (v) =>'function'===typeof v && !!v.prototype && v.prototype.constructor !== v;
```
ご提示いただいたコードは、JavaScriptの関数オブジェクトの性質（
prototypeの有無やtoStringの結果）を深く考察されており、非常に鋭いアプローチです。
しかし、2025年現在のJavaScript仕様に照らし合わせると、いくつかの判定式で意図しない結果（誤判定）が生じる箇所があります。 特に「一般的な関数（function fn(){}）」と「コンストラクタ」の境界線において修正が必要です。
以下に、各式の評価と改善案をまとめます。
1. 各式の検証結果
関数名
	判定対象	評価と注意点
isConClsFn	全般	[OK] すべての関数オブジェクトを捕捉できます。
isConCls	コンストラクタ/クラス	[要注意] function fn(){} で定義した普通の関数もtrueになります。 JSではアロー関数等を除き、普通の関数はすべてコンストラクタとして振る舞えるためです。
isConstructor	ネイティブ/ES5クラス	[概ねOK] ただし後述の「メソッド定義」との区別が必要です。
isCls	ES6クラス	[OK] toString() を使うこの方法は、現在もES6クラスを判別する事実上の標準的な手法です。
isFunction	純粋な関数	[要修正] isConstructorが「普通の関数」を真と判定してしまうため、このままだと常に偽になる可能性があります。
isArrowFunction	アロー関数	[OK] アロー関数と、オブジェクト内のメソッド定義（{ fn(){} }）を捕捉できます。
isDefinedFunction	一般的な関数	[要修正] v.prototype.constructor !== v は通常成立しません（基本は循環参照で一致します）。
2. 修正が必要なポイント：JSの「関数」の二面性
JavaScriptにおいて、function fn(){} で作った関数は、「関数」であると同時に「コンストラクタ（newできる）」でもあります。 これを「ただの関数（non-constructor）」として定義時に区別するプロパティは存在しません。
唯一の例外は、「メソッド定義（Method definitions）」と「アロー関数」です。これらは prototype を持たず、new できません。
3. ブラッシュアップした判定式（2025年版）
「newできるかどうか」と「構文上の出自」をベースに整理したコードです。
javascript

// 1. 全ての関数系 (Class, Function, Arrow, Async, etc...)
const isCallable = (v) => typeof v === 'function';

// 2. ES6 class構文で定義されたもの (class C {})
const isEs6Class = (v) => isCallable(v) && v.toString().startsWith('class ');

// 3. new 演算子で呼び出し可能なもの (ES5以前の関数、Arrayなどの組み込み、ES6クラス)
// ※メソッド定義やアロー関数は prototype を持たないのでここで弾ける
const isConstructor = (v) => isCallable(v) && !!v.prototype;

// 4. ネイティブ実装やES5形式のクラス（Array, Uint8Array, function OldClass(){}）
const isNativeOrEs5Class = (v) => isConstructor(v) && !v.toString().startsWith('class ');

// 5. new できない「純粋な関数」 (アロー関数、オブジェクトのメソッド定義 { m(){} })
const isNonConstructorFunction = (v) => isCallable(v) && !v.prototype;

// 6. アロー関数 (() => {}) の判定
// ※メソッド定義と区別するには toString() のチェックが必要な場合があるが、実用上は 5 と同等
const isArrowFunction = (v) => isNonConstructorFunction(v) && !v.toString().match(/^\w+\s*\(/);

コードは注意してご使用ください。
修正のアドバイス

    v.prototype.constructor !== v について:
    通常の function f(){} では f.prototype.constructor === f は常に true です。そのため、この条件で「一般的な関数」を抽出することはできません。
    「一般的な関数」の定義:
    もし「function fn(){} の形式で書かれたもの」を指すのであれば、それは JavaScript の仕様上、Array 等と区別がつかない（どちらも new 可能な関数オブジェクトである）という点に注意してください。

もし「new されたくない関数」を厳密に作りたい場合は、ES6 以降では const fn = () => {}（アロー関数）や { method() {} }（メソッド定義）を使うのが現在の標準的な設計方針となっています。


JavaScriptではコンストラクタ関数と非コンストラクタ関数を区別することができないという認識で合っていますか？
処理しています
結論から申し上げますと、
「完全に、かつあらゆる環境で100%正確に区別する方法は存在しない」という意味では、そのご認識で合っています。
しかし、2025年現在のモダンなJavaScript環境においては、「オブジェクトの状態」や「特定の構文の挙動」を組み合わせることで、実用上ほぼ正確に区別することが可能です。
なぜ区別が難しいのか、そしてどこまでなら判別できるのかを整理しました。
1. なぜ区別が難しいのか（歴史的背景）
JavaScriptの初期設計では、function キーワードで作られた関数は、「実行可能なコード（Call）」としての側面と、「インスタンスを生成する雛形（Construct）」としての側面の二面性を常に持っていました。
そのため、以下のコードのように、定義側では「ただの関数」のつもりでも、使う側が new を使えばコンストラクタとして動いてしまいます。
javascript

function MyFunction() {}
const obj = new MyFunction(); // エラーにならず、インスタンスが作れてしまう

コードは注意してご使用ください。
2. 「非コンストラクタ」と断定できる関数
一方で、ES6以降に導入された新しい構文で作られた関数は、明確に「コンストラクタ機能」が削ぎ落とされています。 これらは内部的に [[Construct]] というメソッドを持っていないため、明確に区別（判別）可能です。

    アロー関数: const a = () => {}
    メソッド定義: const obj = { method() {} }
    getter/setter: get prop() {}

これらは prototype プロパティを持たない という特徴があるため、以下の判定式で「非コンストラクタ」と断定できます。
javascript

const isNonConstructor = (v) => typeof v === 'function' && !v.hasOwnProperty('prototype');

コードは注意してご使用ください。
3. 「コンストラクタ」と断定できないグレーゾーン
問題は、以下の2つがプログラム上、全く同じ構造（内部スロット）を持っている点です。

    ES5以前の書き方のクラス: function Person(name) { this.name = name; }
    ただの関数: function add(a, b) { return a + b; }

これらは両方とも prototype を持ち、new が可能です。プログラム的に「これは計算用だから new しないでほしい」という開発者の意図を読み取るプロパティは存在しません。
4. 2025年時点での判定の限界まとめ
関数の種類	prototype の有無	new の可否	判定の可否
ES6 class	あり	必須	toString() 等で可能
組み込み (Array等)	あり	可能	[native code] で推測可能
ES5 function	あり	可能	「ただの関数」か「クラス」か区別不能
アロー関数	なし	不可	確実に判定可能
メソッド定義	なし	不可	確実に判定可能
結論

    アロー関数やメソッド定義は、コンストラクタではないと確実に判定できます。
    function キーワードで定義された関数については、それが「計算用の関数」なのか「古いスタイルのクラス（コンストラクタ）」なのかを区別する術はありません。

そのため、現代のJavaScript開発では「function は使わず、クラスなら class、関数なら const + アロー関数（またはメソッド定義）を使う」という書き分けによる区別が推奨されています。



js 以下isConstructorは、ES5のfunctionキーワードを使用した関数とコンストラクタ関数を区別できない言語仕様という認識で合っていますか？

```javascript
const isConstructor = (v) => isCallable(v) && !!v.prototype;
```

アロー関数を使用すれば区別できるとのことですが、JavaScriptはfunctionキーワードによる関数定義を完全に排除できない言語仕様なので以下のような関数名のほうが正確だと思うのですが、どうですか？

```javascript
const isConstructorOrEs5Fn = (v) => isCallable(v) && !!v.prototype;
```

ご認識の通り、
その推察と命名案は非常に正確で、JavaScriptの言語仕様の本質を突いています。
仰る通り、isConstructor という名前では「その関数がコンストラクタ（クラス）として設計されたものかどうか」という意図を判定しているように見えますが、実際には 「new できる構造を持っているか」 を見ているに過ぎないからです。
1. なぜ isConstructorOrEs5Fn の方が正確なのか
JavaScript（ECMAScript）の仕様上、function キーワードで定義された関数は、内部的に [[Call]]（関数として実行）と [[Construct]]（newでインスタンス化）の両方のメソッドを保持します。
そのため、以下の2つは実行エンジンから見れば「同じ種類のオブジェクト」です。
javascript

function calculateSum(a, b) { return a + b; } // 「関数」のつもり
function Person(name) { this.name = name; }     // 「クラス」のつもり

// どちらも isCallable(v) && !!v.prototype が true になる

コードは注意してご使用ください。
この「設計意図」と「内部構造」の乖離を考慮すると、isConstructorOrEs5Fn（コンストラクタまたはES5関数）という名称は、「仕様上の実態」を誠実に表した極めて適切な命名と言えます。
2. 言語仕様としての「function」の立ち位置
ご指摘の通り、JavaScriptは後方互換性を極めて重視する言語であるため、function キーワードによる定義を排除することはできません。

    1995年〜: 全ての関数は function であり、全てが new 可能だった。
    2015年 (ES6)〜: class（new専用）、arrow function（実行専用）が登場し、役割を分担できるようになった。
    現在: それでも古い function 構文は「何にでもなれる曖昧な存在」として残り続けている。

3. より厳密に区別したい場合の現代的なアプローチ
もし「名前」だけでなく、コード的に少しでも「意図」をフィルタリングしたい場合は、2025年現在では以下のような補助的な判定を組み合わせることもありますが、これらも完璧ではありません。

    命名規則による推測: v.name が大文字で始まっているか（Person vs add）。
    ネイティブ判定: v.toString() に [native code] が含まれるか（Array などの組み込みクラスを抽出）。

結論
質問者様の提案される isConstructorOrEs5Fn という命名は、「JavaScriptの function は、コンストラクタとしての性質を切り離せない」 という言語の限界を正しく表現した、技術的に誠実な命名であると評価できます。
ライブラリ開発や、関数のメタプログラミングを行う文脈であれば、この「区別できない」という事実を名前に含めることは、後続のエンジニアにとっても「この判定にはES5の普通の関数も含まれてしまうのだな」という注意喚起になり、有用です。


```javascript
// 1. 全ての関数系 (Class, Function, Arrow, Async, etc...)
const isCallable = (v) => typeof v === 'function';

// 2. ES6 class構文で定義されたもの (class C {})
const isEs6Class = (v) => isCallable(v) && v.toString().startsWith('class ');

// 3. new 演算子で呼び出し可能なもの (ES5以前の関数、Arrayなどの組み込み、ES6クラス)
// ※メソッド定義やアロー関数は prototype を持たないのでここで弾ける
const isConstructorOrEs5Fn = (v) => isCallable(v) && !!v.prototype;

// 4. ネイティブ実装やES5形式のクラス（Array, Uint8Array, function OldClass(){}）
const isNativeOrEs5Class = (v) => isConstructorOrEs5Fn(v) && !v.toString().startsWith('class ');

// 5. new できない「純粋な関数」 (アロー関数、オブジェクトのメソッド定義 { m(){} })
const isNonConstructorFunction = (v) => isCallable(v) && !v.prototype;

// 6. アロー関数 (() => {}) の判定
// ※メソッド定義と区別するには toString() のチェックが必要な場合があるが、実用上は 5 と同等
const isArrowFunction = (v) => isNonConstructorFunction(v) && !v.toString().match(/^\w+\s*\(/);
```
```javascript
class Callable extends TypeAssertion {
    static is(v) {
        if ('function'!==typeof v) {TypeAssertion.throw(null, null, `呼出可能オブジェクト 'function'!==typeof v`, `${typeof v}`)}
        return new Callable(v);
    }
    constructor(v,fn){super(v,fn)}
    get isCallable() {return 'function'===typeof v}
    get isEs6Class() {return this.isCallable(v) && v.toString().startsWith('class ')}
    get isConstructorOrEs5Fn() {return this.isCallable(v) && !!v.prototype}
    get isNativeOrEs5Class() {return this.isConstructorOrEs5Fn(v) && !v.toString().startsWith('class ')}
    get isNonConstructorFunction() {return this.isCallable(v) && !v.prototype}
    get isArrowFunction() {return this.isNonConstructorFunction(v) && !v.toString().match(/^\w+\s*\(/)}
}
```

* isCallable
    * isConstructorOrEs5Fn
        * isEs6Class
        * isNativeOrEs5Class
    * isNonConstructorFunction / isMethodOrArrowFunction 
        * isArrowFunction


以下isNonConstructorFunction関数の名前はisMethodOrArrowFunctionにしたほうが分かりやすいと思いますが、間違いが含みうる名前になりますか？

```javascript
const isNonConstructorFunction = (v) => isCallable(v) && !v.prototype;
```
```javascript
const isMethodOrArrowFunction = (v) => isCallable(v) && !v.prototype; 
```



以下isNonConstructorFunction関数の名前はisMethodOrArrowFunctionにしたほうが分かりやすいと思いますが、間違いが含みうる名前など何か問題があると思いますか？

```javascript
const isNonConstructorFunction = (v) => isCallable(v) && !v.prototype;
```
```javascript
const isMethodOrArrowFunction = (v) => isCallable(v) && !v.prototype; 
```

結論から申し上げますと、その書き換えは
「直感的な分かりやすさ」は向上しますが、技術的な「厳密さ（網羅性）」においては少しだけリスクを含みます。
isMethodOrArrowFunction という名前にした場合に、考慮から漏れる（あるいは誤解を招く）可能性があるパターンが3つあります。
1. 組み込みの「newできない関数」の存在
JavaScriptの組み込み関数（Math.pow、JSON.parse、Array.isView など）の多くは、prototype を持たず new できません。これらは「メソッド」とも「アロー関数」とも呼びにくい、「組み込みの純粋な関数」です。

    isMethodOrArrowFunction(Math.sin) は true になりますが、これを「メソッド」や「アロー関数」と呼ぶのは、用語として少し違和感が生じます。

2. bind された関数の扱い
関数を .bind() した場合、元の関数がコンストラクタであっても、バインド後の関数は prototype を持ちません（ただし、new は可能です。ここは非常に特殊な挙動です）。

    const BoundArray = Array.bind(null)
    BoundArray.prototype は undefined ですが、new BoundArray() は動作します。
    この場合、isMethodOrArrowFunction は true を返しますが、実際には new（Constructor）として動いてしまうという矛盾が生じます。

3. ジェネレータ関数と非同期関数

    ジェネレータ関数 (function* () {}) は prototype を持ちますが、new することはできません。
    非同期関数 (async function () {}) は prototype を持ちません。
    これらを「メソッドやアロー関数」という括りに含めてしまうと、デバッグ時に「これは async 関数なのに、なぜメソッド扱いされているんだ？」と混乱を招く可能性があります。

おすすめの命名案
もし名前にこだわりたい場合は、「何であるか（形態）」よりも「何ができないか（能力）」にフォーカスした名前の方が、将来的な仕様変更や特殊なケースに対しても嘘をつかないコードになります。

    isNonNewableFunction（newできない関数）
        最も技術的に正確です。「prototype がない ＝ new できない」という事実をそのまま表しています。
    isPureFunction（（JS的な意味での）純粋な関数）
        「クラスやインスタンス化の仕組みに関与しない」という意味で使われますが、関数型プログラミングの「純粋関数」と混同されるリスクがあります。
    isFunctionOnly（関数専用）
        コンストラクタとしての側面を持たないことを示唆します。

結論

    個人のプロジェクトやチーム内で意味が通じるなら: isMethodOrArrowFunction でも大きな問題はありません。直感的に「newできないやつら」だと分かります。
    再利用性の高いライブラリや厳密なロジックを作るなら: 質問者様が最初に提示された isNonConstructorFunction、あるいは isNonNewableFunction の方が、JavaScriptの仕様上の境界線を正しく表現できています。

「prototype がない」という状態は、「設計者が明確に new させる意図を捨てた」 という状態を指すので、やはり NonConstructor（非コンストラクタ）という言葉が最も安全かもしれません。

```javascript
class Callable extends TypeAssertion {
    static is(v) {
        if ('function'!==typeof v) {TypeAssertion.throw(null, null, `呼出可能オブジェクト 'function'!==typeof v`, `${typeof v}`)}
        return new Callable(v);
    }
    constructor(v,fn){super(v,fn)}
    get isCallable() {return 'function'===typeof v}
    get isEs6Class() {return this.isCallable(v) && v.toString().startsWith('class ')}
    get isConstructorOrEs5Fn() {return this.isCallable(v) && !!v.prototype}
    get isNativeOrEs5Class() {return this.isConstructorOrEs5Fn(v) && !v.toString().startsWith('class ')}
    get isNonConstructorFunction() {return this.isCallable(v) && !v.prototype}
    get isArrowFunction() {return this.isNonConstructorFunction(v) && !v.toString().match(/^\w+\s*\(/)}
}
```
```javascript
class Callable extends TypeAssertion {
    static is(v) {
        if ('function'!==typeof v) {TypeAssertion.throw(null, null, `呼出可能オブジェクト 'function'!==typeof v`, `${typeof v}`)}
        return new Callable(v);
    }
    constructor(v,fn){super(v,fn)}
    get isCallable() {return 'function'===typeof v}
    get isEs6Cls() {return this.isCallable(v) && v.toString().startsWith('class ')}
    get isConOrEs5Fn() {return this.isCallable(v) && !!v.prototype} // コンストラクタかES5関数
    get isNativeOrEs5Cls() {return this.isConOrEs5Fn(v) && !v.toString().startsWith('class ')} // 組込コードかES5クラス
    get isNonConFn() {return this.isCallable(v) && !v.prototype} // アロー関数、メソッド、組込new不能関数、bind()済関数、ジェネレータ関数、Async関数
    get isArrFn() {return this.isNonConFn(v) && !v.toString().match(/^\w+\s*\(/)}
}
```

* isCallable
    * isConOrEs5Fn
        * isEs6Class
        * isNativeOrEs5Cls
    * isNonConFn
        * isArrFn

```javascript
class NonConFn extends Callable {
    static is(v) {
        if ('function'!==typeof v) {TypeAssertion.throw(null, null, `呼出可能オブジェクト 'function'!==typeof v`, `${typeof v}`)}
        return new Callable(v);
    }
    constructor(v,fn){super(v,fn)}
    get isAsync() {}
    get isGen() {}
    get isAsyncGen() {}
    get isAsyncal() {}
    get isGenal() {}
    get notAsyncal() {}
    get notGenal() {}
    get notAsyncGenal() {}
}
```
```javascript
class ArrFn extends NonConFn {
    static is(v) {
        if ('function'!==typeof v) {TypeAssertion.throw(null, null, `呼出可能オブジェクト 'function'!==typeof v`, `${typeof v}`)}
        return new Callable(v);
    }
    constructor(v,fn){super(v,fn)}
    get isAsync() {}
    get isGen() {}
    get isAsyncGen() {}
    get isAsyncal() {}
    get isGenal() {}
    get notAsyncal() {}
    get notGenal() {}
    get notAsyncGenal() {}
}
```



js Instanceオブジェクトをクラスオブジェクト、関数オブジェクト、ディスクリプタオブジェクトと区別する方法。以下の?の部分を埋めてください。

```javascript
const isCallable = (v) => typeof v === 'function'; // クラス・関数はここに含まれる
const isDescriptor = (v) => ?;
const isInstance = (v) => ?;
```


```javascript
/**
 * プロパティ記述子（Descriptor）かどうかを判定
 * データ記述子（value/writable）またはアクセサ記述子（get/set）のいずれかの構成を持つオブジェクト
 */
const isDescriptor = (v) => {
  if (v === null || typeof v !== 'object') return false;
  
  // get, set, value, writable, enumerable, configurable のいずれかを持っているか
  const has = (key) => Object.prototype.hasOwnProperty.call(v, key);
  const isData = has('value') || has('writable');
  const isAccessor = has('get') || has('set');
  
  // 有効なディスクリプタは、データとアクセサの両方を持つことはできない（JS仕様）
  return (isData || isAccessor) && !(isData && isAccessor);
};
/**
 * インスタンスオブジェクトかどうかを判定
 * 「関数（クラス）ではなく」「ディスクリプタでもなく」「nullではないオブジェクト」
 */
const isInstance = (v) => {
  return v !== null && 
         typeof v === 'object' && 
         !isCallable(v) && 
         !isDescriptor(v);
};
```

