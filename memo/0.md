# JavaScript 型

```
[object Class.SomeClass]
[object Instance.SomeClass]
[object Error.Class.TypeError]
[object Error.Instance.TypeError]
[object Function.Function]
[object Function.Async]
[object Function.Generator]
[object Function.AsyncGenerator]
[object Object]
[object Class.Array]
[object Instance.Array]
[object Class.Map]
[object Instance.Map]
```
```
[primitive undefined]
[primitive null]
[primitive symbol]
[primitive boolean]
[primitive bigint]
[primitive string]
[primitive number.NaN]
[primitive number.PositiveInfinity]
[primitive number.NegativeInfinity]
[primitive number.SafeInteger]
[primitive number.Integer]
[primitive number.Float]
```
```
isObjLike();
isPrim();

clsOf(v); // v = SomeClass
insOf(v); // v = SomeClass
prmOf(v); // v = null/undefined/Boolean/BigInt/String/Number(NaN/Infinity/-Infinity/SafeInteger/Integer/Float)
```

## Some

```javascript
class SomeTypedValue {
    static assert(v, a) {
        // a=>v.isP.isNum.isNaN
        // a=>v.isP.isNum.isNaN.value(v=>任意の式。trueを返せば成功)
        // a=>v.isA.length(7).every(v=>'number'===typeof v) // Array
        // a=>v.isM.size(7).has(keys).keys(k=>).value(v=>).entires((k,v)=>) // Map
        // a=>v.isS.size(7).has(keys).keys(k=>).value(v=>).entires((k,v)=>) // Set
        // a=>v.isFn
        // a=>v.isAFn
        // a=>v.isGFn
        // a=>v.isAGFn
        // a=>v.isAFnLike
        // a=>v.isGFnLike
        // a=>v.isFnLike
        // a=>v.isC.hasP('someMethod').hasD('someDescriptor', v=>v.hasGS).hasM('someMethod')
        // a=>v.isI.hasP('someMethod').hasD('someDescriptor', v=>v.hasGS).hasM('someMethod')
        // a=>v.isEC.hasP('someMethod').hasD('someDescriptor', v=>v.hasGS).hasM('someMethod')
        // a=>v.isEI.hasP('someMethod').hasD('someDescriptor', v=>v.hasGS).hasM('someMethod')
        // a=>v.isOL.hasP('someProp') // OL: ObjectLike
        // a=>v.isO.hasP('someProp') // O: Object {}
        // a=>v.isO.hasF('someFunction')
        // a=>v.isO.hasD('someDescriptor')
        // a=>v.isO.hasD('someDescriptor', a=>v.hasGS || v.hasG || v.hasS || v.hasV || v.writable || v.configurable || v.enumerable)
        // a=>v.isO.hasO('someProp')
        // a=>v.isO.hasO('someProp', a=>a.hasP('someProp'))
    }
    static tag(v) {

    }
    static getDefaultValue(fn) {

    }
    constructor(v) {
        this._ = {v:v, t:typeof v};
    }
}
```
```javascript
class SomeTypedValueAssertion {
    constructor(v) {this._ = {v:v}}
    assert(fn) {return fn(this._.v)}
    eq(v) {}
    get isP() {}
    get isA() {}
    get isM() {}
    get isS() {}
    get isC() {}
    get isI() {}
    get isEC() {}
    get isEI() {}
    get isFn() {}
    get isAFn() {}
    get isGFn() {}
    get isAGFn() {}
    get isAFnLike() {}
    get isGFnLike() {}
    get isFnLike() {}
    get isOLike() {}
    get isO() {}
}
class PrimitivedValueAssertion {
    constructor(v) {this._ = {v:v}}
    get isUnd() {}
    get isNul() {}
    get isSym() {}
    get isBln() {}
    get isNum() {}
    get isInt() {}
    get isStr() {}
}
class BooleanedValueAssertion {
    constructor(v) {this._ = {v:v}}
    get isT() {}
    get isF() {}
}
class NumberedValueAssertion {
    constructor(v) {this._ = {v:v}}
    get isNaN() {}
    get isPInf() {}
    get isNInf() {}
    get isFin() {}
    get isP() {}
    get isN() {}
    get isZ() {}
    get isSafeInt() {}
    get isInt() {}
}
class StringedValueAssertion {
    constructor(v) {this._ = {v:v}}
    length(n) {}
}
```


## Primitive

```javascript
class PrimitivedValue {
     constructor(v) {
        this._ = {v:v};
        this._.t = typeof v;
        if (!(null===this._.t || 'undefined symbol boolean number bigint string'.split(' ').some(t=>t===this._.t))) {throw new TypeError(`vはプリミティブ値であるべきです。: ${this._.t}, ${v}`)}
    }
    get v() {return this._.v}
    set v(v) {
        const t = typeof v;
        if (this._.t!==t) {throw new TypeError(`代入値はtypeofが ${this._.t} を返す値のみ有効です。: ${t}, ${v}`)}
    }
}
class ValidPrimitivedValue extends PrimitivedValue {
    constructor(v) {
        super(v);
        if (Number.isNaN(v)) {throw new TypeError(`vはNaNを禁じます。`)}
        if (null===v) {throw new TypeError(`vはnullを禁じます。`)}
        if (undefined===v) {throw new TypeError(`vはundefinedを禁じます。`)}
    }
    get v() {return super.v}
    set v(v) {
        if (Number.isNaN(v)) {throw new TypeError(`vはNaNを禁じます。`)}
        super.v = v;
    }
}
```

## Object

```javascript
class ObjectLikedValue {
    constructor(v, nullable=false) {
        this._ = {v:v, t:typeof v, nullable:nullable};
        if ('boolean'!==nullable) {throw new TypeError(`nullableはBoolean値であるべきです。`)}
//        if (!this._.nullable && null===this._.t) {throw new TypeError(`nullableがfalseなのに値がnullです。`)}
//        if ('object'!==this._.t) {throw new TypeError(`vはtypeofで'object'を返す値であるべきです。`)}
        this.v = v;
    }
    get v() {return this._.v}
    set v(v) {
        const t = typeof v;
        if (!this._.nullable && null===v) {throw new TypeError(`nullableがfalseなのに値がnullです。`)}
        if ('object'!==t) {throw new TypeError(`代入値はtypeofが 'object' を返す値のみ有効です。: ${t}, ${v}`)}
        this._.v = v;
    }
}
```
```javascript
class ObjectedValue extends ObjectLikedValue {
    static is(v) {return null!==v && 'object'===typeof v && '[object Object]'===Object.prototype.call.toString(v)}
    constructor(v,nullable=false) {super(v,nullable); this.v = v;}
    get v() {return super.v}
    set v(v) {
        super.v = v;
        if ('[object Object]'!==Object.prototype.call.toString(v)) {throw new TypeError(`代入値はObject.prototype.call.toString(v)が'[object Object]'を返す値のみ有効です。`)}
    }
}
```
```javascript
class ErrorClassedValue extends ObjectLikedValue {
    static is(v) {return Error===v || Error.isPrototypeOf(v)}
    constructor(v,nullable=false) {super(v,nullable); this.v = v;}
    get v() {return super.v}
    set v(v) {
        super.v = v;
        if (!ErrorClassedValue.is(v)) {throw new TypeError(`代入値はError型かそれを継承したクラスオブジェクトであるべきです。`)}
    }
}
class ErrorInstancedValue extends ObjectLikedValue {
    static is(v) {return v instanceof Error}
    constructor(v,nullable=false) {super(v,nullable); this.v = v;}
    get v() {return super.v}
    set v(v) {
        super.v = v;
        if (!ErrorInstancedValue.is(v)) {throw new TypeError(`代入値はError型かそれを継承したクラスのインスタンスオブジェクトであるべきです。`)}
    }
}
class ClassedValue extends ObjectLikedValue {
    static is(v) {return 'function'===typeof v && Boolean(v.toString?.().match(/^class /))}
    constructor(v,nullable=false) {super(v,nullable); this.v = v;}
    get v() {return super.v}
    set v(v) {
        super.v = v;
        if (!('function'===typeof v && Boolean(v.toString?.().match(/^class /))) {throw new TypeError(`代入値はクラスオブジェクトであるべきです。`)}
    }
}
class InstancedValue extends ObjectLikedValue {
    constructor(v, cls=null, nullable=false) {
        super(v,nullable);
        this.v = v;
        this._.cls=cls;
        if (null!==cls && !ErrorClassedValue.is(v)){throw new TypeError(`clsはnullかクラスオブジェクトのみ有効です。`)}
    }
    get v() {return super.v}
    set v(v) {
        super.v = v;
        const t = typeof v;
        if ('function'!==t) {throw new TypeError(`代入値はインスタンスのみ有効なのに関数が渡されました。:${t}, ${v}`)}
        if (!ClassedValue.is(v)) {throw new TypeError(`代入値はインスタンスのみ有効なのにクラスが渡されました。:${t}, ${v}`)}
        if (!ErrorClassedValue.is(v)) {throw new TypeError(`代入値はインスタンスのみ有効なのにエラークラスオブジェクトが渡されました。:${t}, ${v}`)}
        if (!ErrorInstancedValue.is(v)) {throw new TypeError(`代入値はインスタンスのみ有効なのにエラーインスタンスオブジェクトが渡されました。:${t}, ${v}`)}
        if (!ObjectedValue.is(v)) {throw new TypeError(`代入値はインスタンスのみ有効なのにオブジェクトが渡されました。:${t}, ${v}`)}
        if (this._.cls && v !(instanceof this._.cls)) {throw new TypeError(`代入値は${this._.cls.name}クラスのインスタンスのみ有効です。:${t}, ${v}`)}
    }
}
```

## Function

```javasctipt
class FunctionLikedValue {
    is(v) {return 'function'===typeof v}
    constructor(v, nullable=false) {
        this._ = {v:v, nullable:nullable}
        if ('boolean'!==nullable) {throw new TypeError(`nullableはBoolean値であるべきです。`)}
        this.v = v;
    }
    get v() {return this._.v}
    set v(v) {
        if (!this._.nullable && null===v) {throw new TypeError(`nullableがfalseなのにnullが代入されました。`)}
        if (!FunctionedValue.is(v)) {throw new TypError(`代入値は関数のみ有効です。`)}
        this._.v = v;
    }
}
class FunctionedValue extends FunctionLikedValue {
    static is(v) {return FunctionLikedValue.is(v) && !(AsyncFunctionLikedValue.is(v) || GeneratorFunctionLikedValue(v))}
    constructor(v, nullable=false) {
        super(v, nullable);
        this.v = v;
    }
    get v() {return super.v}
    set v(v) {
        super.v = v;
        if (!FunctionedValue.is(v)) {throw new TypeError(`非同期でもジェネレータでもない関数のみ有効です。:${v}`)}
    }
}
class AsyncFunctionedValue extends FunctionLikedValue {
    static #T = (async()=>{}).constructor;
    static is(v) {return v instanceof this.#T}
    constructor(v, nullable=false) {
        super(v, nullable);
        this.v = v;
    }
    get v() {return super.v}
    set v(v) {
        super.v = v;
        if (!AsyncFunctionedValue.is(v)) {throw new TypeError(`非同期関数のみ有効です。:${v}`)}
    }
}
class GeneratorFunctionedValue extends FunctionLikedValue {
    static #T = (function*(){yield undefined;}).constructor;
    static is(v) {return v instanceof this.#T}
    constructor(v, nullable=false) {
        super(v, nullable);
        this.v = v;
    }
    get v() {return super.v}
    set v(v) {
        super.v = v;
        if (!GeneratorFunctionedValue .is(v)) {throw new TypeError(`ジェネレータ関数のみ有効です。:${v}`)}
    }
}
class AsyncGeneratorFunctionedValue extends FunctionLikedValue {
    static #T = (async function*(){yield undefined;}).constructor;
    static is(v) {return v instanceof this.#T}
    constructor(v, nullable=false) {
        super(v, nullable);
        this.v = v;
    }
    get v() {return super.v}
    set v(v) {
        super.v = v;
        if (!AsyncGeneratorFunctionedValue.is(v)) {throw new TypeError(`非同期ジェネレータ関数のみ有効です。:${v}`)}
    }
}

class AsyncFunctionLikedValue extends FunctionLikedValue {
    static is(v) {return AsyncFunctionedValue.is(v) || AsyncGeneratorFunctionedValue.is(v)}
    constructor(v, nullable=false) {
        super(v, nullable);
        this.v = v;
    }
    get v() {return super._.v}
    set v(v) {
        super.v = v;
        if (!AsyncGeneratorFunctionedValue.is(v)) {throw new TypeError(`非同期系関数のみ有効です。:${v}`)}
    }
}
class GeneratorFunctionLikedValue extends FunctionLikedValue {
    static is(v) {return GeneratorFunctionedValue.is(v) || AsyncGeneratorFunctionedValue.is(v)}
    constructor(v, nullable=false) {
        super(v, nullable);
        this.v = v;
    }
    get v() {return super._.v}
    set v(v) {
        super.v = v;
        if (!GeneratorFunctionLikedValue.is(v)) {throw new TypeError(`ジェネレータ系関数のみ有効です。:${v}`)}
    }
}
```

## Number型

* NaN,Infinity,-Infinityを除外する
* IEEE754倍精度浮動小数点のうち
    * 誤差が生じないSafeInteger
    * 誤差が生じるInteger
    * 誤差が生じるFinite(Float)

```javascript
class Finite extends Number {
    constructor(v) {this._={v:0}; this.v=v;}
    get v() {return this._.v}
    set v(v) {
        if (Number.isFinite(v)) {throw new TypeError(`代入値が不正です。Number.isFinite()がtrueを返す値のみ有効です。`)}
        this._.v = v;
    }
}
class Integer extends Finite {
    constructor(v) {super(v); this.v=v;}
    get v() {return this._.v}
    set v(v) {
        if (Number.isInteger(v)) {throw new TypeError(`代入値が不正です。Number.isInteger()がtrueを返す値のみ有効です。`)}
        this._.v = v;
    }
}
class SafeInteger extends Integer {
    constructor(v) {super(v); this.v=v;}
    get v() {return this._.v}
    set v(v) {
        if (Number.isSafeInteger(v)) {throw new TypeError(`代入値が不正です。Number.isInteger()がtrueを返す値のみ有効です。`)}
        this._.v = v;
    }
}
```

### RangedNumber型

　Finite,Integer,SafeIntegerの中でも更に範囲を限定する。

```javascript
class Range {static valid(min,max) {if (max <= min) {throw new RangeError(`min < maxであるべきです。`)}}}
class NumberTypedRange {
    static get validTypes() {return [Finite,Integer,SafeInteger]}
    constructor(T, min, max, v) {
        this._ = {T:T};
        if (!TypedRange.validTypes.some(t=>t===T)) {throw new TypeError(`Tは${TypedRange.validTypes}のいずれかであるべきです。`)}
        this._.min = new T(min);
        this._.max = new T(max);
        if (max <= min) {throw new RangeError(`min < maxであるべきです。`)}
        this._.v = new T(v ?? 0);
    }
    get min() {return this._.min.v}
//    set min(v) {this._.min.v=v}
    get max() {return this._.max.v}
//    set max(v) {this._.max.v=v}    
    get v() {return this._.v.v}
    set v(v) {this._.v.v=v}    
}
class RangedFinite extends NumberTypedRange {constructor(min,max,v) {super(Finite,min,max,v)}}
class RangedInteger extends NumberTypedRange {constructor(min,max,v) {super(Integer,min,max,v)}}
class RangedSafeInteger extends NumberTypedRange {constructor(min,max,v) {super(SafeInteger,min,max,v)}}
class RangedBigInt {
    static get validTypes() {return [Finite,Integer,SafeInteger,BigInt]}
    constructor(min, max, v) {
        this._ = {};
        if ([min,max].every('bigint'!==v)) {throw new TypeError(`min,maxは共にtypeofが'bigint'を返す値であるべきです。`)}
        this._.min = BigInt(min);
        this._.max = BigInt(max);
        if (max <= min) {throw new RangeError(`min < maxであるべきです。`)}
        this._.v = BigInt(v ?? 0n);
        this.#valid(v);
    }
    get min() {return this._.min}
//    set min(v) {this.#valid(v); this._.min=v}
    get max() {return this._.max}
//    set max(v) {this.#valid(v); this._.max=v}    
    get v() {return this._.v}
    set v(v) {this.#valid(v); this._.v=v}    
    #valid(v) {if ('bigint'!==v) {throw new TypeError(`vはtypeofが'bigint'を返す値であるべきです。`)}}
}

### TwoPowRangedNumber型

　範囲制限の中でも2の冪乗である数。

```javascript
class SignedInteger8   extends RangedSafeInteger {constructor(v) {super(-128, 127, v);}}
class SignedInteger16  extends RangedSafeInteger {constructor(v) {super(-32768, 32767, v);}}
class SignedInteger32  extends RangedSafeInteger {constructor(v) {super(-2147483648, 2147483647, v);}}
class SignedInteger64  extends RangedBigInt {constructor(v) {super(-9223372036854775808n, 9223372036854775807n, v);}}
class SignedInteger128 extends RangedBigInt {constructor(v) {super(-170141183460469231731687303715884105728n, 170141183460469231731687303715884105727n, v);}}
class SignedInteger256 extends RangedBigInt {constructor(v) {super(-57896044618658097711785492504343953926634992332820282019728792003956564819968n, 57896044618658097711785492504343953926634992332820282019728792003956564819967n, v);}}
class UnsignedInteger8   extends RangedSafeInteger {constructor(v) {super(0, 256, v);}}
class UnsignedInteger16  extends RangedSafeInteger {constructor(v) {super(0, 65536, v);}}
class UnsignedInteger32  extends RangedSafeInteger {constructor(v) {super(0, 4294967295, v);}}
class UnsignedInteger64  extends RangedBigInt {constructor(v) {super(0n, 18446744073709551615n, v);}}
class UnsignedInteger128 extends RangedBigInt {constructor(v) {super(0n, 340282366920938463463374607431768211455n, v);}}
class UnsignedInteger256 extends RangedBigInt {constructor(v) {super(0n, 115792089237316195423570985008687907853269984665640564039457584007913129639935n, v);}}
newTwoPowInteger(pow, signed, value) {
    if (Number.isSafeInteger(pow) && 0 < pow) {throw new TypeError(`powはNumber.isSafeInteger()がtrueを返す値で0より大きい数であるべきです。`)}
    if ('boolean'!==typeof signed) {throw new TypeError(`signedは真偽値であるべきです。`)}
    const [min,max] = pow < 53
        ? [(signed ? ((2**pow) / 2) * -1) : 0), (((2**pow) / (signed ? 2 : 1)) - 1)]
        : [(signed ? ((2n**pow) / 2n) * -1n) : 0n), (((2n**pow) / (signed ? 2n : 1n)) - 1n)]
    const T = pow < 53 ? RangedBigInt : RangedSafeInteger;
    return new T(min,max,value);
}
window.Typed = new Proxy({},{
    get(target, prop, receiver) {
        const R = /^(?<signed>(i|u))(?<bits>\d+)$/;
        const m = prop.match(R);
        if (!m) {throw new TypeError(`プロパティ名が不正です。次の正規表現に従った名前にしてください。${R}`)}
        const signed = 'i'===m.groups.signed ? true : false;
        const bits = parseInt(m.groups.bits);
        if (!(0 < bits && (0===(bits & (bits - 1)))) {throw new RangeError(`bitsは8以上かつ2の冪乗であるべきです。例:8,16,32,64,128,256`)}
        return newTwoPowInteger(pow, signed, value);
    }
});
window.Typed.i(); // Number.isSafeInteger()全部
window.Typed.u(); // 0以上のNumber.isSafeInteger()全部
window.Typed.f(); // Finite（UnsafeなIntegerを含む。浮動小数点数を含む）
window.Typed.u8();
window.Typed.u8(0);
window.Typed.i8(0);
window.Typed.u16(0);
window.Typed.u32(0);
window.Typed.u64(0);
window.Typed.u128(0);
window.Typed.u256(0);
window.Typed.ir(min,max,v); // 整数範囲
window.Typed.ur(max,v);     // 整数範囲
window.Typed.fr(min,max,v); // 実数範囲
```

## 乱数

```javascript
window.Random.f(min, max); // min,maxの範囲内を均等分布で出力する
window.Random.i(min, max); // min,maxの範囲内を均等分布で出力する
window.Random.u(max); // min,maxの範囲内を均等分布で出力する
window.Random.u8; // min,maxの範囲内を均等分布で出力する
window.Random.i8; // min,maxの範囲内を均等分布で出力する
```
```javascript
window.Random.id;    // UnsignedInteger,128bitsの乱数。内部ではUint8ArrayやBase64化した文字列を持
window.Random.id256; // UnsignedInteger,256bitsの乱数。内部ではUint8ArrayやBase64化した文字列を持
```

# 全部

```javascript
window.Typed = {
    some: (v)=>,
    Primitive: (v)=>new PrimitivedValue(v),
    ObjectLike: (v)=>new ObjectLikedValue(v),
    Object: (v)=>new ObjectedValue(v),
    Class: (v)=>new ClassedValue(v),
    Instance: (v)=>new InstanceedValue(v),
    ErrorClass: (v)=>new ErrorClassedValue(v),
    ErrorInstance: (v)=>new ErrorInstanceedValue(v),
    Number: new Proxy({
            f: (v)=>new Finite(v),
            i: (v)=>new SafeInteger(v),
            u: (v)=>new RangedSafeInteger(Number.SAFE_MAX_INTEGER, v),
            fr: (min,max,v)=>new RangedFinite(min,max,v),
            ir: (min,max,v)=>new RangedSafeInteger(min,max,v),
            ur: (max,v)=>new RangedSafeInteger(0,max,v),
        },{
        get(target, prop, receiver) {
            if (prop in target) {return Reflect.get(target, prop)}
            const R = /^(?<signed>(i|u))(?<bits>\d+)$/;
            const m = prop.match(R);
            if (!m) {throw new TypeError(`プロパティ名が不正です。次の正規表現に従った名前にしてください。${R}`)}
            const signed = 'i'===m.groups.signed ? true : false;
            const bits = parseInt(m.groups.bits);
            if (!(0 < bits && (0===(bits & (bits - 1))))) {throw new RangeError(`bitsは8以上かつ2の冪乗であるべきです。例:8,16,32,64,128,256`)}
            return newTwoPowInteger(pow, signed, value);
        }
    }),
    Random: {
        id: ()=>new RID(),
    },
    BiasRandom: {
        
    },
};
```

